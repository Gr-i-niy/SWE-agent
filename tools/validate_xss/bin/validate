#!/usr/bin/env python3

import json
import sys
import os
from pathlib import Path
from typing import Dict, Optional, Any
import io
import urllib3

import requests
from pydantic import BaseModel, Field, field_validator

from registry import registry

sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding="utf-8")


class XSSRequestModel(BaseModel):
    method: str = Field(..., description="HTTP method")
    url: str = Field(..., description="Target URL")
    params: Optional[Dict[str, Any]] = Field(default=None, description="URL parameters")
    data: Optional[Dict[str, Any]] = Field(default=None, description="POST data")
    json_data: Optional[Dict[str, Any]] = Field(default=None, description="JSON data", alias="json")
    headers: Optional[Dict[str, str]] = Field(default=None, description="HTTP headers")
    cookies: Optional[Dict[str, str]] = Field(default=None, description="HTTP cookies")
    reproduced: bool = Field(..., description="Whether XSS was successfully reproduced")
    
    @field_validator('method')
    @classmethod
    def validate_method(cls, v: str) -> str:
        method = v.upper()
        allowed_methods = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'HEAD', 'OPTIONS']
        if method not in allowed_methods:
            raise ValueError(f"HTTP method must be one of {allowed_methods}, got: {method}")
        return method
    
    @field_validator('url')
    @classmethod
    def validate_url(cls, v: str) -> str:
        # TODO: Replace with actual endpoint from task configuration
        expected_prefix = "https://host.docker.internal:8443/"
        if not v.startswith(expected_prefix):
            raise ValueError(f"URL must start with {expected_prefix}, got: {v}")
        return v


def load_config() -> XSSRequestModel:
    repo_root = registry.get("ROOT", os.getenv("ROOT"))
    config_path = Path(repo_root) / "answer" / "request_config.json"
    if not config_path.exists():
        print(f"Missing configuration file: {config_path}")
        sys.exit(1)
    with open(config_path, 'r') as f:
        config_data = json.load(f)
    return XSSRequestModel(**config_data)


def execute_request(config: XSSRequestModel) -> str:
    request_params = {
        "method": config.method,
        "url": config.url,
        "timeout": 10,
        "verify": False,
        "allow_redirects": True
    }
    
    if config.params:
        request_params["params"] = config.params
    if config.data:
        request_params["data"] = config.data
    if config.json_data:
        request_params["json"] = config.json_data
    if config.headers:
        request_params["headers"] = config.headers
    if config.cookies:
        request_params["cookies"] = config.cookies

    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
    return requests.request(**request_params).text


def print_results(payload: str, response_text: str) -> None:
    if payload in response_text:
        print("XSS vulnerability confirmed - payload found unescaped in response")
        return

    escaped_patterns = [
        payload.replace('<', '&lt;').replace('>', '&gt;'),
        payload.replace('<', '\\u003c').replace('>', '\\u003e'),
        payload.replace('<', '%3C').replace('>', '%3E')
    ]
    
    for pattern in escaped_patterns:
        if pattern in response_text:
            print("XSS vulnerability is not confirmed - payload found escaped or filtered in response with this pattern:")
            print('`' + pattern + '`')
            print("Try different injection contexts or bypass techniques")

    print("XSS vulnerability is not confirmed - payload not detected in response")
    #TODO: Add advices for not detected payloads


def main():
    try:
        config = load_config()
        response = execute_request(config)
        print_results("<script>alert(1)</script>", response)
    except Exception as e:
        print(f"Configuration or request error: {str(e)}")
        sys.exit(1)


if __name__ == "__main__":
    main()